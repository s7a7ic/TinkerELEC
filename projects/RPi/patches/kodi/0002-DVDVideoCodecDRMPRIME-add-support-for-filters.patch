From 7fe467bbbc02f410dcd42314ab79a05ff525e212 Mon Sep 17 00:00:00 2001
From: Jonas Karlman <jonas@kwiboo.se>
Date: Sun, 20 Oct 2019 17:10:07 +0000
Subject: [PATCH 2/2] DVDVideoCodecDRMPRIME: add support for filters

DRMPRIME deinterlace filter

DVDVideoCodecDRMPRIME: Fix Format calls and some logging

DVDVideoCodecDRMPRIME: Avoid exception with AV_PIX_FMT_NONE

DVDVideoCodecDRMPRIME: Also support YUV420 buffers

DVDVideoCodecDRMPRIME: Add support for deinterlace of sw decoded buffers

Need to call SetDimensions earlier and store the drm descriptor in expected place

DVDVideoCodecDRMPRIME: Leave deinterlace filter active on a progressive frame

Interlaced content often has strange mixtures of interlace and progressive frames (e.g. IIPPPPIIPPPP)
and currently we can be creating and destroying the deinterlace filter graph almost every frame.

If it's been created, then leave it active until end of file. The frames marked as progressive should
be just copied by deinterlace filter

SetVideoInterlaced: Set and unset deinterlace method name reported

DVDVideoCodecDRMPRIME: Close deinterlace filter on error

Otherwise we crash later with an invalid m_pFilterGraph pointer

DVDVideoCodecDRMPRIME: Adjust av formats to match recent ffmpeg changes

DVDVideoCodecDRMPRIME: Add support for arbitrary output pixel formats

This enables any ffmpeg pixel formats to be supported by DRMPRIME decoder
by creating a scale ffmpeg filter to convert it to a supported format.

This allows formats like h264 Hi10P and hevc 12-bit 444 to be software decoded,
converted and displayed through DRM.

This will be a cheaper path than disabling DRMPRIME, which is also
software decode, convert, but then needs convert to texture and display through GL.

And it happens automatically without requiring user video settings

DVDVideoCodecDRMPRIME: Remove obsolete thread_safe_callbacks

DVDVideoCodecDRMPRIME: Fix missing flush after eof

DVDVideoCodecDRMPRIME: Clear m_pFilterGraph

DVDVideoCodecDRMPRIME: Move FilterTest from open to first frame returned

The pixel format is not accurate until the first frame is returned
and it may (later) influence the choice of deinterlacers available.

DVDVideoCodecDRMPRIME: Rework filtering code to handle sw deinterlace

DVDVideoCodecDRMPRIME: Support decoding to DRMPRIME with sw deinterlace

We can map a YUV style DRM_PRIME buffer back to AV_PIX_FMT_YUV420P
to allow subsquent sw deinterlace

DVDVideoCodecDRMPRIME: Request v4l2 buffers be allocated through cache

This is an optional request, but will improve performance of sw deinterlace
if supported.

DVDVideoCodecDRMPRIME: Add setting to enable hw deinterlace

HW deinterlace has lower cpu, but may have higher quality,
so allow user to choose appropriate setting.
---
 .../resources/strings.po                      |  11 +
 system/settings/linux.xml                     |  12 +
 .../DVDCodecs/Video/DVDVideoCodecDRMPRIME.cpp | 499 ++++++++++++++++--
 .../DVDCodecs/Video/DVDVideoCodecDRMPRIME.h   |  23 +-
 xbmc/settings/Settings.h                      |   1 +
 5 files changed, 507 insertions(+), 39 deletions(-)

diff --git a/addons/resource.language.en_gb/resources/strings.po b/addons/resource.language.en_gb/resources/strings.po
index 587bb7d6f2d4..9953521a20c9 100644
--- a/addons/resource.language.en_gb/resources/strings.po
+++ b/addons/resource.language.en_gb/resources/strings.po
@@ -7551,6 +7551,11 @@ msgctxt "#13438"
 msgid "Allow hardware acceleration with DRM PRIME"
 msgstr ""
 
+#: system/settings/settings.xml
+msgctxt "#13500"
+msgid "Allow hardware deinterlace with DRM PRIME"
+msgstr ""
+
 #: system/settings/settings.xml
 msgctxt "#13439"
 msgid "Allow hardware acceleration - MediaCodec"
@@ -20029,6 +20034,12 @@ msgctxt "#36172"
 msgid "Enable PRIME decoding of video files"
 msgstr ""
 
+#. Description of setting with label #13500 "Allow hardware deinterlace - PRIME"
+#: system/settings/settings.xml
+msgctxt "#36290"
+msgid "Enable PRIME hardware deinterlace of video files"
+msgstr ""
+
 #. Description of setting with label #14109 "Short date format"
 #: system/settings/settings.xml
 msgctxt "#36173"
diff --git a/system/settings/linux.xml b/system/settings/linux.xml
index 6c2db262e13b..ebc355e69696 100644
--- a/system/settings/linux.xml
+++ b/system/settings/linux.xml
@@ -192,6 +192,18 @@
           <default>true</default>
           <control type="toggle" />
         </setting>
+        <setting id="videoplayer.primeallowhwdeinterlace" type="boolean" parent="videoplayer.useprimedecoder" label="13500" help="36290">
+          <requirement>HAS_GLES</requirement>
+          <visible>false</visible>
+          <dependencies>
+            <dependency type="enable">
+              <condition setting="videoplayer.useprimedecoder" operator="is">true</condition>
+            </dependency>
+          </dependencies>
+          <level>3</level>
+          <default>true</default>
+          <control type="toggle" />
+        </setting>
         <setting id="videoplayer.useprimerenderer" type="integer" label="13462" help="13463">
           <requirement>HAS_GLES</requirement>
           <visible>false</visible>
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecDRMPRIME.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecDRMPRIME.cpp
index 07c505213691..c6cd64922c39 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecDRMPRIME.cpp
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecDRMPRIME.cpp
@@ -28,6 +28,8 @@
 extern "C"
 {
 #include <libavcodec/avcodec.h>
+#include <libavfilter/buffersink.h>
+#include <libavfilter/buffersrc.h>
 #include <libavutil/error.h>
 #include <libavutil/imgutils.h>
 #include <libavutil/opt.h>
@@ -38,6 +40,7 @@ namespace
 {
 
 constexpr const char* SETTING_VIDEOPLAYER_USEPRIMEDECODERFORHW{"videoplayer.useprimedecoderforhw"};
+constexpr const char* SETTING_VIDEOPLAYER_ALLOWHWDEINTERLACE{"videoplayer.primeallowhwdeinterlace"};
 
 static void ReleaseBuffer(void* opaque, uint8_t* data)
 {
@@ -90,12 +93,15 @@ CDVDVideoCodecDRMPRIME::CDVDVideoCodecDRMPRIME(CProcessInfo& processInfo)
   : CDVDVideoCodec(processInfo)
 {
   m_pFrame = av_frame_alloc();
+  m_pFilterFrame = av_frame_alloc();
   m_videoBufferPool = std::make_shared<CVideoBufferPoolDRMPRIMEFFmpeg>();
 }
 
 CDVDVideoCodecDRMPRIME::~CDVDVideoCodecDRMPRIME()
 {
   av_frame_free(&m_pFrame);
+  av_frame_free(&m_pFilterFrame);
+  FilterClose();
   avcodec_free_context(&m_pCodecContext);
 }
 
@@ -143,6 +149,15 @@ void CDVDVideoCodecDRMPRIME::Register()
 
   setting->SetVisible(true);
 
+  setting = settings->GetSetting(SETTING_VIDEOPLAYER_ALLOWHWDEINTERLACE);
+  if (!setting)
+  {
+    CLog::Log(LOGERROR, "Failed to load setting for: {}", SETTING_VIDEOPLAYER_ALLOWHWDEINTERLACE);
+    return;
+  }
+
+  setting->SetVisible(true);
+
   CDVDFactoryCodec::RegisterHWVideoCodec("drm_prime", CDVDVideoCodecDRMPRIME::Create);
 }
 
@@ -198,11 +213,7 @@ static const AVCodec* FindDecoder(CDVDStreamInfo& hints)
         return codec;
     }
 
-  codec = avcodec_find_decoder(hints.codec);
-  if (codec && (codec->capabilities & AV_CODEC_CAP_DR1) == AV_CODEC_CAP_DR1)
-    return codec;
-
-  return nullptr;
+  return avcodec_find_decoder(hints.codec);
 }
 
 enum AVPixelFormat CDVDVideoCodecDRMPRIME::GetFormat(struct AVCodecContext* avctx,
@@ -210,7 +221,7 @@ enum AVPixelFormat CDVDVideoCodecDRMPRIME::GetFormat(struct AVCodecContext* avct
 {
   for (int n = 0; fmt[n] != AV_PIX_FMT_NONE; n++)
   {
-    if (IsSupportedHwFormat(fmt[n]) || IsSupportedSwFormat(fmt[n]))
+    //if (IsSupportedHwFormat(fmt[n]) || IsSupportedSwFormat(fmt[n]))
     {
       CDVDVideoCodecDRMPRIME* ctx = static_cast<CDVDVideoCodecDRMPRIME*>(avctx->opaque);
       ctx->UpdateProcessInfo(avctx, fmt[n]);
@@ -231,7 +242,8 @@ enum AVPixelFormat CDVDVideoCodecDRMPRIME::GetFormat(struct AVCodecContext* avct
 
 int CDVDVideoCodecDRMPRIME::GetBuffer(struct AVCodecContext* avctx, AVFrame* frame, int flags)
 {
-  if (IsSupportedSwFormat(static_cast<AVPixelFormat>(frame->format)))
+  AVPixelFormat pix_fmt = static_cast<AVPixelFormat>(frame->format);
+  if (IsSupportedSwFormat(pix_fmt))
   {
     int width = frame->width;
     int height = frame->height;
@@ -239,7 +251,7 @@ int CDVDVideoCodecDRMPRIME::GetBuffer(struct AVCodecContext* avctx, AVFrame* fra
     AlignedSize(avctx, width, height);
 
     int size;
-    switch (avctx->pix_fmt)
+    switch (pix_fmt)
     {
       case AV_PIX_FMT_YUV420P:
       case AV_PIX_FMT_YUVJ420P:
@@ -259,13 +271,12 @@ int CDVDVideoCodecDRMPRIME::GetBuffer(struct AVCodecContext* avctx, AVFrame* fra
 
     CDVDVideoCodecDRMPRIME* ctx = static_cast<CDVDVideoCodecDRMPRIME*>(avctx->opaque);
     auto buffer = dynamic_cast<CVideoBufferDMA*>(
-        ctx->m_processInfo.GetVideoBufferManager().Get(avctx->pix_fmt, size, nullptr));
+        ctx->m_processInfo.GetVideoBufferManager().Get(pix_fmt, size, nullptr));
     if (!buffer)
       return -1;
 
-    frame->opaque = static_cast<void*>(buffer);
     frame->opaque_ref =
-        av_buffer_create(nullptr, 0, ReleaseBuffer, frame->opaque, AV_BUFFER_FLAG_READONLY);
+        av_buffer_create(nullptr, 0, ReleaseBuffer, static_cast<void*>(buffer), AV_BUFFER_FLAG_READONLY);
 
     buffer->Export(frame, width, height);
     buffer->SyncStart();
@@ -369,6 +380,10 @@ bool CDVDVideoCodecDRMPRIME::Open(CDVDStreamInfo& hints, CDVDCodecOptions& optio
   for (auto&& option : options.m_keys)
     av_opt_set(m_pCodecContext, option.m_name.c_str(), option.m_value.c_str(), 0);
 
+  // this requests v4l2 buffers are allocated through cache. It will work if this is not supported,
+  // but subsequent operations like deinterlace may be less efficient
+  av_opt_set(m_pCodecContext->priv_data, "dmabuf_alloc", "cma", 0);
+
   if (avcodec_open2(m_pCodecContext, pCodec, nullptr) < 0)
   {
     CLog::Log(LOGINFO, "CDVDVideoCodecDRMPRIME::{} - unable to open codec", __FUNCTION__);
@@ -381,9 +396,12 @@ bool CDVDVideoCodecDRMPRIME::Open(CDVDStreamInfo& hints, CDVDCodecOptions& optio
   }
 
   UpdateProcessInfo(m_pCodecContext, m_pCodecContext->pix_fmt);
+  m_processInfo.SetVideoInterlaced(false);
   m_processInfo.SetVideoDeintMethod("none");
   m_processInfo.SetVideoDAR(hints.aspect);
 
+  m_checkedDeinterlace = false;
+
   return true;
 }
 
@@ -458,6 +476,8 @@ void CDVDVideoCodecDRMPRIME::Reset()
     return;
 
   Drain();
+  m_filters.clear();
+  FilterClose();
 
   do
   {
@@ -505,7 +525,7 @@ void CDVDVideoCodecDRMPRIME::Drain()
   av_packet_free(&avpkt);
 }
 
-void CDVDVideoCodecDRMPRIME::SetPictureParams(VideoPicture* pVideoPicture)
+bool CDVDVideoCodecDRMPRIME::SetPictureParams(VideoPicture* pVideoPicture)
 {
   pVideoPicture->iWidth = m_pFrame->width;
   pVideoPicture->iHeight = m_pFrame->height;
@@ -601,6 +621,370 @@ void CDVDVideoCodecDRMPRIME::SetPictureParams(VideoPicture* pVideoPicture)
                            ? DVD_NOPTS_VALUE
                            : static_cast<double>(pts) * DVD_TIME_BASE / AV_TIME_BASE;
   pVideoPicture->dts = DVD_NOPTS_VALUE;
+
+  if (pVideoPicture->videoBuffer)
+  {
+    pVideoPicture->videoBuffer->Release();
+    pVideoPicture->videoBuffer = nullptr;
+  }
+
+  if (m_pFrame->format == AV_PIX_FMT_DRM_PRIME)
+  {
+    CVideoBufferDRMPRIMEFFmpeg* buffer =
+        dynamic_cast<CVideoBufferDRMPRIMEFFmpeg*>(m_videoBufferPool->Get());
+    buffer->SetPictureParams(*pVideoPicture);
+    buffer->SetRef(m_pFrame);
+    pVideoPicture->videoBuffer = buffer;
+  }
+  else if (IsSupportedSwFormat(static_cast<AVPixelFormat>(m_pFrame->format)))
+  {
+    CVideoBufferDMA* buffer = static_cast<CVideoBufferDMA*>(av_buffer_get_opaque(m_pFrame->buf[0]));
+    buffer->SetPictureParams(*pVideoPicture);
+    buffer->Acquire();
+    buffer->SyncEnd();
+    buffer->SetDimensions(m_pFrame->width, m_pFrame->height);
+
+    pVideoPicture->videoBuffer = buffer;
+    av_frame_unref(m_pFrame);
+  }
+
+  if (!pVideoPicture->videoBuffer)
+  {
+    CLog::Log(LOGERROR, "CDVDVideoCodecDRMPRIME::{} - videoBuffer:nullptr format:{}", __FUNCTION__,
+              m_pFrame->format == AV_PIX_FMT_NONE ? "AV_PIX_FMT_NONE" : av_get_pix_fmt_name(static_cast<AVPixelFormat>(m_pFrame->format)));
+    av_frame_unref(m_pFrame);
+    return false;
+  }
+
+  return true;
+}
+
+void CDVDVideoCodecDRMPRIME::FilterTest(AVPixelFormat pix_fmt)
+{
+  m_deintFilterName.clear();
+
+  // look twice, first for DRM_PRIME support, then for actual pixel format
+
+  bool hw = CServiceBroker::GetSettingsComponent()->GetSettings()->GetBool(
+      SETTING_VIDEOPLAYER_ALLOWHWDEINTERLACE);
+
+  for (int i = hw ? 0 : 1; i < 2; i++)
+  {
+    const AVFilter* filter;
+    void* opaque{};
+
+    while ((filter = av_filter_iterate(&opaque)) != nullptr)
+    {
+      std::string name(filter->name);
+
+      if (name.find(i == 0 ? "deinterlace" : "bwdif") != std::string::npos)
+      {
+        bool ret = FilterOpen(name, pix_fmt, true);
+        FilterClose();
+        if (ret)
+        {
+          m_deintFilterName = name;
+          if (name == "bwdif" || name == "yadif")
+            m_deintFilterName += "=1:-1:1";
+          CLog::Log(LOGDEBUG, "CDVDVideoCodecDRMPRIME::{} - found deinterlacing filter {}",
+                    __FUNCTION__, name);
+          return;
+        }
+      }
+    }
+  }
+
+  CLog::Log(LOGDEBUG, "CDVDVideoCodecDRMPRIME::{} - no deinterlacing filter found",
+            __FUNCTION__);
+}
+
+AVFrame *CDVDVideoCodecDRMPRIME::alloc_filter_frame(AVFilterContext * ctx, void * v, int w, int h)
+{
+  int result;
+  CDVDVideoCodecDRMPRIME* me = static_cast<CDVDVideoCodecDRMPRIME*>(v);
+  AVFrame *frame = av_frame_alloc();
+  frame->width = w;
+  frame->height = h;
+  frame->format = AV_PIX_FMT_YUV420P;
+
+  if ((result = CDVDVideoCodecDRMPRIME::GetBuffer(me->m_pCodecContext, frame, 0)) < 0)
+  {
+    CLog::Log(LOGERROR, "CDVDVideoCodecDRMPRIME::alloc_filter_frame - failed to GetBuffer ({})", result);
+    return nullptr;
+  }
+  return frame;
+}
+
+bool CDVDVideoCodecDRMPRIME::FilterOpen(const std::string& filters, AVPixelFormat pix_fmt, bool test)
+{
+  int result;
+
+  if (filters.find("deinterlace") != std::string::npos && pix_fmt == AV_PIX_FMT_YUV420P)
+     pix_fmt = AV_PIX_FMT_DRM_PRIME;
+
+  if (filters.find("bwdif") != std::string::npos && pix_fmt == AV_PIX_FMT_DRM_PRIME)
+     pix_fmt = AV_PIX_FMT_YUV420P;
+
+  if (m_pFilterGraph)
+    FilterClose();
+
+  if (filters.empty())
+    return true;
+
+  if (!(m_pFilterGraph = avfilter_graph_alloc()))
+  {
+    CLog::Log(LOGERROR, "CDVDVideoCodecDRMPRIME::FilterOpen - unable to alloc filter graph");
+    return false;
+  }
+
+  m_pFilterIn = avfilter_graph_alloc_filter(m_pFilterGraph, avfilter_get_by_name("buffer"), "in");
+  if (m_pFilterIn == NULL)
+  {
+    CLog::Log(LOGERROR, "CDVDVideoCodecDRMPRIME::FilterOpen - avfilter_graph_create_filter: failed to create in graph");
+    return false;
+  }
+
+  AVBufferSrcParameters *par = av_buffersrc_parameters_alloc();
+  if (!par)
+  {
+    CLog::Log(LOGERROR, "CDVDVideoCodecDRMPRIME::FilterOpen - unable to alloc buffersrc");
+    return false;
+  }
+
+  memset(par, 0, sizeof(*par));
+  par->format = pix_fmt;
+  par->width = m_pCodecContext->width;
+  par->height = m_pCodecContext->height;
+#if LIBAVFILTER_BUILD >= AV_VERSION_INT(10, 1, 100)
+  par->color_range = m_pCodecContext->color_range;
+  par->color_space = m_pCodecContext->colorspace;
+#endif
+  par->time_base = m_pCodecContext->time_base;
+  par->sample_aspect_ratio = m_pCodecContext->sample_aspect_ratio;
+
+  if (pix_fmt == AV_PIX_FMT_DRM_PRIME)
+  {
+    if (av_hwdevice_ctx_create(&m_hw_device_ref, AV_HWDEVICE_TYPE_DRM, NULL, NULL, 0) < 0) {
+        CLog::Log(LOGERROR, "Failed to create DRM device");
+        return false;
+    }
+    m_hw_frames_ref = av_hwframe_ctx_alloc(m_hw_device_ref);
+    if (!m_hw_frames_ref) {
+      CLog::Log(LOGERROR, "Failed to allocate hwframe context");
+        av_buffer_unref(&m_hw_device_ref);
+        return false;
+    }
+    par->hw_frames_ctx = av_buffer_ref(m_hw_frames_ref);
+  }
+
+  result = av_buffersrc_parameters_set(m_pFilterIn, par);
+  if (result < 0)
+  {
+    char err[AV_ERROR_MAX_STRING_SIZE] = {};
+    av_strerror(result, err, AV_ERROR_MAX_STRING_SIZE);
+    CLog::Log(LOGERROR,
+              "CDVDVideoCodecDRMPRIME::FilterOpen - av_buffersrc_parameters_set:  {} ({})",
+              err, result);
+    return false;
+  }
+  av_freep(&par);
+
+  result = avfilter_init_dict(m_pFilterIn, NULL);
+  if (result < 0)
+  {
+    CLog::Log(LOGERROR, "CDVDVideoCodecDRMPRIME::FilterOpen - Failed to init in dict (%d)", result);
+    return false;
+  }
+
+  m_pFilterOut = avfilter_graph_alloc_filter(m_pFilterGraph, avfilter_get_by_name("buffersink"), "out");
+  if (m_pFilterOut == NULL)
+  {
+    CLog::Log(LOGERROR, "CDVDVideoCodecDRMPRIME::FilterOpen - avfilter_graph_create_filter: failed to create out graph");
+    return false;
+  }
+
+  enum AVPixelFormat pix_fmts[] = { AV_PIX_FMT_DRM_PRIME, AV_PIX_FMT_YUV420P, AV_PIX_FMT_NONE };
+#if LIBAVFILTER_BUILD >= AV_VERSION_INT(10, 6, 100)
+  result = av_opt_set_array(m_pFilterOut, "pixel_formats",
+                          AV_OPT_SEARCH_CHILDREN | AV_OPT_ARRAY_REPLACE,
+                          0, sizeof(pix_fmts)/sizeof(pix_fmts[0]) - 1,
+                          AV_OPT_TYPE_PIXEL_FMT, pix_fmts);
+#else
+  result = av_opt_set_int_list(m_pFilterOut, "pix_fmts", &pix_fmts[0],
+                               AV_PIX_FMT_NONE, AV_OPT_SEARCH_CHILDREN);
+#endif
+  if (result < 0)
+  {
+    CLog::Log(LOGERROR, "CDVDVideoCodecDRMPRIME::FilterOpen - failed settings pix formats (%d)", result);
+    return false;
+  }
+
+  result = avfilter_init_dict(m_pFilterOut, NULL);
+  if (result < 0)
+  {
+      CLog::Log(LOGERROR, "CDVDVideoCodecDRMPRIME::FilterOpen - Failed to init out dict (%d)", result);
+      return false;
+  }
+
+  if ((result = av_buffersink_set_alloc_video_frame(m_pFilterOut, alloc_filter_frame, static_cast<void*>(this))) < 0)
+  {
+    CLog::Log(LOGERROR, "CDVDVideoCodecDRMPRIME::FilterOpen - av_buffersink_set_alloc_video_frame = {}", result);
+    return result;
+  }
+  AVFilterInOut* outputs = avfilter_inout_alloc();
+  AVFilterInOut* inputs  = avfilter_inout_alloc();
+
+  outputs->name = av_strdup("in");
+  outputs->filter_ctx = m_pFilterIn;
+  outputs->pad_idx = 0;
+  outputs->next = nullptr;
+
+  inputs->name = av_strdup("out");
+  inputs->filter_ctx = m_pFilterOut;
+  inputs->pad_idx = 0;
+  inputs->next = nullptr;
+
+  result = avfilter_graph_parse_ptr(m_pFilterGraph, filters.c_str(), &inputs, &outputs, NULL);
+  avfilter_inout_free(&outputs);
+  avfilter_inout_free(&inputs);
+
+  if (result < 0)
+  {
+    CLog::Log(LOGERROR, "CDVDVideoCodecDRMPRIME::FilterOpen - avfilter_graph_parse");
+    return false;
+  }
+
+  if ((result = avfilter_graph_config(m_pFilterGraph,  nullptr)) < 0)
+  {
+    char err[AV_ERROR_MAX_STRING_SIZE] = {};
+    av_strerror(result, err, AV_ERROR_MAX_STRING_SIZE);
+    CLog::Log(LOGERROR, "CDVDVideoCodecDRMPRIME::FilterOpen - avfilter_graph_config:  {} ({})",
+              err, result);
+    return false;
+  }
+
+  if (test)
+    return true;
+
+  if (CServiceBroker::GetLogging().CanLogComponent(LOGVIDEO))
+  {
+    char* graphDump = avfilter_graph_dump(m_pFilterGraph, nullptr);
+    if (graphDump)
+    {
+      CLog::Log(LOGDEBUG, "CDVDVideoCodecDRMPRIME::FilterOpen - Final filter graph:\n{}",
+                graphDump);
+      av_freep(&graphDump);
+    }
+  }
+
+  return true;
+}
+
+void CDVDVideoCodecDRMPRIME::FilterClose()
+{
+  m_processInfo.SetVideoDeintMethod("none");
+  if (m_pFilterGraph)
+  {
+    CLog::Log(LOGDEBUG, LOGVIDEO, "CDVDVideoCodecDRMPRIME::FilterClose - Freeing filter graph");
+    avfilter_graph_free(&m_pFilterGraph);
+
+    // Disposed by above code
+    m_pFilterIn = nullptr;
+    m_pFilterOut = nullptr;
+    m_pFilterGraph = nullptr;
+    av_buffer_unref(&m_hw_frames_ref);
+    av_buffer_unref(&m_hw_device_ref);
+  }
+}
+
+CDVDVideoCodec::VCReturn CDVDVideoCodecDRMPRIME::ProcessFilterIn()
+{
+  // sw decoded buffers submitted to hw decoder need cache flush and for descripter to be set
+  if (m_pFrame->format != AV_PIX_FMT_DRM_PRIME && m_pFilterGraph && m_pFilterIn->outputs[0]->format == AV_PIX_FMT_DRM_PRIME)
+  {
+    CVideoBufferDMA* buffer = static_cast<CVideoBufferDMA*>(av_buffer_get_opaque(m_pFrame->buf[0]));
+    buffer->SetDimensions(m_pFrame->width, m_pFrame->height);
+    buffer->SyncEnd();
+    auto descriptor = buffer->GetDescriptor();
+    m_pFrame->data[0] = reinterpret_cast<uint8_t*>(descriptor);
+    m_pFrame->format = AV_PIX_FMT_DRM_PRIME;
+  }
+  // hw decoded buffers submitted to sw decoder need mapping of planes for cpu to access
+  else if (m_pFrame->format == AV_PIX_FMT_DRM_PRIME && m_pFilterGraph && m_pFilterIn->outputs[0]->format == AV_PIX_FMT_YUV420P)
+  {
+    AVFrame *frame = av_frame_alloc();
+    frame->width = m_pFrame->width;
+    frame->height = m_pFrame->height;
+    frame->format = AV_PIX_FMT_YUV420P;
+    int ret = av_hwframe_map(frame, m_pFrame, (int)AV_HWFRAME_MAP_READ);
+    if (ret < 0)
+    {
+      char err[AV_ERROR_MAX_STRING_SIZE] = {};
+      av_strerror(ret, err, AV_ERROR_MAX_STRING_SIZE);
+      CLog::Log(LOGERROR, "CDVDVideoCodecDRMPRIME::{} - av_hwframe_map failed: {} ({})",
+                __FUNCTION__, err, ret);
+      return VC_ERROR;
+    }
+    av_frame_unref(m_pFrame);
+    av_frame_move_ref(m_pFrame, frame);
+  }
+
+  int ret = av_buffersrc_add_frame(m_pFilterIn, m_pFrame);
+  if (ret < 0)
+  {
+    char err[AV_ERROR_MAX_STRING_SIZE] = {};
+    av_strerror(ret, err, AV_ERROR_MAX_STRING_SIZE);
+    CLog::Log(LOGERROR, "CDVDVideoCodecDRMPRIME::{} - buffersrc add frame failed: {} ({})",
+              __FUNCTION__, err, ret);
+    return VC_ERROR;
+  }
+
+  return ProcessFilterOut();
+}
+
+CDVDVideoCodec::VCReturn CDVDVideoCodecDRMPRIME::ProcessFilterOut()
+{
+  int ret = av_buffersink_get_frame(m_pFilterOut, m_pFilterFrame);
+  if (ret == AVERROR(EAGAIN))
+    return VC_BUFFER;
+  else if (ret == AVERROR_EOF)
+  {
+    ret = av_buffersink_get_frame(m_pFilterOut, m_pFilterFrame);
+    if (ret < 0)
+      return VC_BUFFER;
+  }
+  else if (ret)
+  {
+    char err[AV_ERROR_MAX_STRING_SIZE] = {};
+    av_strerror(ret, err, AV_ERROR_MAX_STRING_SIZE);
+    CLog::Log(LOGERROR, "CDVDVideoCodecDRMPRIME::{} - buffersink get frame failed: {} ({})",
+              __FUNCTION__, err, ret);
+    return VC_ERROR;
+  }
+
+  av_frame_unref(m_pFrame);
+  av_frame_move_ref(m_pFrame, m_pFilterFrame);
+
+  return VC_PICTURE;
+}
+
+std::string CDVDVideoCodecDRMPRIME::GetFilterChain(bool interlaced)
+{
+  // ask codec to do deinterlacing if possible
+  EINTERLACEMETHOD mInt = m_processInfo.GetVideoSettings().m_InterlaceMethod;
+  std::string filterChain;
+
+  if (!m_processInfo.Supports(mInt))
+    mInt = m_processInfo.GetFallbackDeintMethod();
+
+  // avoid disabling deinterlace graph for occasional progressive frames - they will be copied by deinterlace
+  if (!m_filters.empty())
+    interlaced = true;
+
+  if (mInt != VS_INTERLACEMETHOD_NONE && interlaced && !m_deintFilterName.empty())
+    filterChain += m_deintFilterName;
+
+  return filterChain;
 }
 
 CDVDVideoCodec::VCReturn CDVDVideoCodecDRMPRIME::GetPicture(VideoPicture* pVideoPicture)
@@ -608,6 +992,21 @@ CDVDVideoCodec::VCReturn CDVDVideoCodecDRMPRIME::GetPicture(VideoPicture* pVideo
   if (m_codecControlFlags & DVD_CODEC_CTRL_DRAIN)
     Drain();
 
+  if (m_pFilterGraph)
+  {
+    auto ret = ProcessFilterOut();
+    if (ret == VC_PICTURE)
+    {
+      if (!SetPictureParams(pVideoPicture))
+        return VC_ERROR;
+      return VC_PICTURE;
+    }
+    else if (ret != VC_BUFFER)
+    {
+      return ret;
+    }
+  }
+
   int ret = avcodec_receive_frame(m_pCodecContext, m_pFrame);
   if (ret == AVERROR(EAGAIN))
     return VC_BUFFER;
@@ -630,41 +1029,65 @@ CDVDVideoCodec::VCReturn CDVDVideoCodecDRMPRIME::GetPicture(VideoPicture* pVideo
     return VC_ERROR;
   }
 
-  SetPictureParams(pVideoPicture);
-
-  if (pVideoPicture->videoBuffer)
+  AVPixelFormat pix_fmt = static_cast<AVPixelFormat>(m_pFrame->format);
+  if (!m_checkedDeinterlace)
   {
-    pVideoPicture->videoBuffer->Release();
-    pVideoPicture->videoBuffer = nullptr;
+    FilterTest(pix_fmt);
+
+    if (!m_deintFilterName.empty())
+    {
+      std::list<EINTERLACEMETHOD> methods;
+      methods.push_back(EINTERLACEMETHOD::VS_INTERLACEMETHOD_DEINTERLACE);
+      m_processInfo.UpdateDeinterlacingMethods(methods);
+      m_processInfo.SetDeinterlacingMethodDefault(EINTERLACEMETHOD::VS_INTERLACEMETHOD_DEINTERLACE);
+    }
+    m_checkedDeinterlace = true;
   }
 
-  if (IsSupportedHwFormat(static_cast<AVPixelFormat>(m_pFrame->format)))
+  if (!m_processInfo.GetVideoInterlaced() && (m_pFrame->flags & AV_FRAME_FLAG_INTERLACED))
+    m_processInfo.SetVideoInterlaced(true);
+
+  std::string filterChain = GetFilterChain(m_pFrame->flags & AV_FRAME_FLAG_INTERLACED);
+
+  // we need to scale if the buffer isn't in DRM_PRIME format
+  if (!IsSupportedSwFormat(pix_fmt) && !IsSupportedHwFormat(pix_fmt))
+    filterChain = "scale";
+  // we need to copy if the buffer wasn't allocated by us
+  else if (!IsSupportedHwFormat(pix_fmt) && !(m_pCodecContext->codec->capabilities & AV_CODEC_CAP_DR1))
+    filterChain = "copy";
+
+  if (!filterChain.empty())
   {
-    CVideoBufferDRMPRIMEFFmpeg* buffer =
-        dynamic_cast<CVideoBufferDRMPRIMEFFmpeg*>(m_videoBufferPool->Get());
-    buffer->SetPictureParams(*pVideoPicture);
-    buffer->SetRef(m_pFrame);
-    pVideoPicture->videoBuffer = buffer;
+    bool reopenFilter = m_filters != filterChain;
+
+    if (m_pFilterGraph &&
+        (m_pFilterIn->outputs[0]->w != m_pFrame->width ||
+         m_pFilterIn->outputs[0]->h != m_pFrame->height))
+      reopenFilter = true;
+
+    if (reopenFilter)
+    {
+      m_filters = filterChain;
+      m_processInfo.SetVideoDeintMethod(m_filters);
+
+      if (!FilterOpen(filterChain, pix_fmt, false))
+        FilterClose();
+    }
+
+    if (m_pFilterGraph)
+    {
+      if (ProcessFilterIn() != VC_PICTURE)
+        return VC_NONE;
+    }
   }
-  else if (m_pFrame->opaque)
+  else
   {
-    CVideoBufferDMA* buffer = static_cast<CVideoBufferDMA*>(m_pFrame->opaque);
-    buffer->SetPictureParams(*pVideoPicture);
-    buffer->Acquire();
-    buffer->SyncEnd();
-    buffer->SetDimensions(m_pFrame->width, m_pFrame->height);
-
-    pVideoPicture->videoBuffer = buffer;
-    av_frame_unref(m_pFrame);
+    m_filters.clear();
+    FilterClose();
   }
 
-  if (!pVideoPicture->videoBuffer)
-  {
-    CLog::Log(LOGERROR, "CDVDVideoCodecDRMPRIME::{} - videoBuffer:nullptr format:{}", __FUNCTION__,
-              av_get_pix_fmt_name(static_cast<AVPixelFormat>(m_pFrame->format)));
-    av_frame_unref(m_pFrame);
+  if (!SetPictureParams(pVideoPicture))
     return VC_ERROR;
-  }
 
   return VC_PICTURE;
 }
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecDRMPRIME.h b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecDRMPRIME.h
index db49d165e7ba..64c6c029f3d4 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecDRMPRIME.h
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecDRMPRIME.h
@@ -14,6 +14,11 @@
 
 #include <memory>
 
+extern "C"
+{
+#include <libavfilter/avfilter.h>
+}
+
 class CDVDVideoCodecDRMPRIME : public CDVDVideoCodec
 {
 public:
@@ -33,16 +38,32 @@ public:
 
 protected:
   void Drain();
-  void SetPictureParams(VideoPicture* pVideoPicture);
+  bool SetPictureParams(VideoPicture* pVideoPicture);
   void UpdateProcessInfo(struct AVCodecContext* avctx, const enum AVPixelFormat fmt);
+  CDVDVideoCodec::VCReturn ProcessFilterIn();
+  CDVDVideoCodec::VCReturn ProcessFilterOut();
   static enum AVPixelFormat GetFormat(struct AVCodecContext* avctx, const enum AVPixelFormat* fmt);
   static int GetBuffer(struct AVCodecContext* avctx, AVFrame* frame, int flags);
+  static AVFrame *alloc_filter_frame(AVFilterContext * ctx, void * v, int w, int h);
+  bool FilterOpen(const std::string& filters, AVPixelFormat pix_fmt, bool test);
+  void FilterClose();
+  void FilterTest(AVPixelFormat pix_fmt);
+  std::string GetFilterChain(bool interlaced);
 
   std::string m_name;
+  std::string m_deintFilterName;
+  std::string m_filters;
   int m_codecControlFlags = 0;
   CDVDStreamInfo m_hints;
   double m_DAR = 1.0;
+  bool m_checkedDeinterlace = false;
   AVCodecContext* m_pCodecContext = nullptr;
   AVFrame* m_pFrame = nullptr;
+  AVFrame* m_pFilterFrame = nullptr;
+  AVFilterGraph* m_pFilterGraph = nullptr;
+  AVFilterContext* m_pFilterIn = nullptr;
+  AVFilterContext* m_pFilterOut = nullptr;
   std::shared_ptr<IVideoBufferPool> m_videoBufferPool;
+  AVBufferRef *m_hw_device_ref = nullptr;
+  AVBufferRef *m_hw_frames_ref = nullptr;
 };
diff --git a/xbmc/settings/Settings.h b/xbmc/settings/Settings.h
index f70a19900c4b..3c2bbeadcf3e 100644
--- a/xbmc/settings/Settings.h
+++ b/xbmc/settings/Settings.h
@@ -123,6 +123,7 @@ public:
   static constexpr auto SETTING_VIDEOPLAYER_USEMEDIACODECSURFACE =
       "videoplayer.usemediacodecsurface";
   static constexpr auto SETTING_VIDEOPLAYER_USEDECODERFILTER = "videoplayer.usedecoderfilter";
+  static constexpr auto SETTING_VIDEOPLAYER_ALLOWHWDEINTERLACE = "videoplayer.primeallowhwdeinterlace";
   static constexpr auto SETTING_VIDEOPLAYER_USEVDPAU = "videoplayer.usevdpau";
   static constexpr auto SETTING_VIDEOPLAYER_USEVDPAUMIXER = "videoplayer.usevdpaumixer";
   static constexpr auto SETTING_VIDEOPLAYER_USEVDPAUMPEG2 = "videoplayer.usevdpaumpeg2";
-- 
2.47.3

