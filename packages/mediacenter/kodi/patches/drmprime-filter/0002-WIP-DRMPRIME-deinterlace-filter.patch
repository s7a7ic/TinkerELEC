From c691db32ae31c6d70c3381cc4876e8f6c9473320 Mon Sep 17 00:00:00 2001
From: Jernej Skrabec <jernej.skrabec@siol.net>
Date: Thu, 26 Dec 2019 11:01:51 +0100
Subject: [PATCH 2/2] WIP: DRMPRIME deinterlace filter

DVDVideoCodecDRMPRIME: Avoid exception with AV_PIX_FMT_NONE

DVDVideoCodecDRMPRIME: Leave deinterlace filter active on a progressive frame

Interlaced content often has strange mixtures of interlace and progressive frames (e.g. IIPPPPIIPPPP)
and currently we can be creating and destroying the deinterlace filter graph almost every frame.

If it's been created, then leave it active until end of file. The frames marked as progressive should
be just copied by deinterlace filter

SetVideoInterlaced: Set and unset deinterlace method name reported

DVDVideoCodecDRMPRIME: Close deinterlace filter on error

Otherwise we crash later with an invalid m_pFilterGraph pointer

DVDVideoCodecDRMPRIME: Move FilterTest from open to first frame returned

The pixel format is not accurate until the first frame is returned
and it may (later) influence the choice of deinterlacers available.
---
 .../DVDCodecs/Video/DVDVideoCodecDRMPRIME.cpp | 407 +++++++++++++++---
 .../DVDCodecs/Video/DVDVideoCodecDRMPRIME.h   |  10 +-
 2 files changed, 359 insertions(+), 58 deletions(-)

diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecDRMPRIME.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecDRMPRIME.cpp
index 24552cc1f0ba..94a717e6399a 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecDRMPRIME.cpp
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecDRMPRIME.cpp
@@ -92,12 +92,15 @@ CDVDVideoCodecDRMPRIME::CDVDVideoCodecDRMPRIME(CProcessInfo& processInfo)
   : CDVDVideoCodec(processInfo)
 {
   m_pFrame = av_frame_alloc();
+  m_pFilterFrame = av_frame_alloc();
   m_videoBufferPool = std::make_shared<CVideoBufferPoolDRMPRIMEFFmpeg>();
 }
 
 CDVDVideoCodecDRMPRIME::~CDVDVideoCodecDRMPRIME()
 {
   av_frame_free(&m_pFrame);
+  av_frame_free(&m_pFilterFrame);
+  FilterClose();
   avcodec_free_context(&m_pCodecContext);
 }
 
@@ -379,8 +382,11 @@ bool CDVDVideoCodecDRMPRIME::Open(CDVDStreamInfo& hints, CDVDCodecOptions& optio
   }
 
   UpdateProcessInfo(m_pCodecContext, m_pCodecContext->pix_fmt);
-  m_processInfo.SetVideoDeintMethod("none");
+  m_processInfo.SetVideoInterlaced(false);
   m_processInfo.SetVideoDAR(hints.aspect);
+  m_processInfo.SetVideoDeintMethod("none");
+
+  m_checkedDeinterlace = false;
 
   return true;
 }
@@ -456,6 +462,8 @@ void CDVDVideoCodecDRMPRIME::Reset()
     return;
 
   Drain();
+  m_filters.clear();
+  FilterClose();
 
   do
   {
@@ -503,7 +511,7 @@ void CDVDVideoCodecDRMPRIME::Drain()
   av_packet_free(&avpkt);
 }
 
-void CDVDVideoCodecDRMPRIME::SetPictureParams(VideoPicture* pVideoPicture)
+bool CDVDVideoCodecDRMPRIME::SetPictureParams(VideoPicture* pVideoPicture)
 {
   pVideoPicture->iWidth = m_pFrame->width;
   pVideoPicture->iHeight = m_pFrame->height;
@@ -598,13 +606,253 @@ void CDVDVideoCodecDRMPRIME::SetPictureParams(VideoPicture* pVideoPicture)
                            ? DVD_NOPTS_VALUE
                            : static_cast<double>(pts) * DVD_TIME_BASE / AV_TIME_BASE;
   pVideoPicture->dts = DVD_NOPTS_VALUE;
+
+  if (pVideoPicture->videoBuffer)
+  {
+    pVideoPicture->videoBuffer->Release();
+    pVideoPicture->videoBuffer = nullptr;
+  }
+
+  if (IsSupportedHwFormat(static_cast<AVPixelFormat>(m_pFrame->format)))
+  {
+    CVideoBufferDRMPRIMEFFmpeg* buffer =
+        dynamic_cast<CVideoBufferDRMPRIMEFFmpeg*>(m_videoBufferPool->Get());
+    buffer->SetPictureParams(*pVideoPicture);
+    buffer->SetRef(m_pFrame);
+    pVideoPicture->videoBuffer = buffer;
+  }
+  else if (m_pFrame->opaque)
+  {
+    CVideoBufferDMA* buffer = static_cast<CVideoBufferDMA*>(m_pFrame->opaque);
+    buffer->SetPictureParams(*pVideoPicture);
+    buffer->Acquire();
+    buffer->SyncEnd();
+    buffer->SetDimensions(m_pFrame->width, m_pFrame->height);
+
+    pVideoPicture->videoBuffer = buffer;
+    av_frame_unref(m_pFrame);
+  }
+
+  if (!pVideoPicture->videoBuffer)
+  {
+    CLog::Log(LOGERROR, "CDVDVideoCodecDRMPRIME::{} - videoBuffer:nullptr format:{}", __FUNCTION__,
+              m_pFrame->format == AV_PIX_FMT_NONE ? "AV_PIX_FMT_NONE" : av_get_pix_fmt_name(static_cast<AVPixelFormat>(m_pFrame->format)));
+    av_frame_unref(m_pFrame);
+    return false;
+  }
+
+  return true;
 }
 
-CDVDVideoCodec::VCReturn CDVDVideoCodecDRMPRIME::ProcessFilterIn()
+void CDVDVideoCodecDRMPRIME::FilterTest()
+{
+  const AVFilter* filter;
+  void* opaque{};
+
+  m_deintFilterName.clear();
+
+  while ((filter = av_filter_iterate(&opaque)) != nullptr)
+  {
+    std::string name(filter->name);
+
+    if (name.find("deinterlace") != std::string::npos)
+    {
+      if (FilterOpen(name, true))
+      {
+        m_deintFilterName = name;
+
+        CLog::Log(LOGDEBUG, "CDVDVideoCodecDRMPRIME::{} - found deinterlacing filter {}",
+                  __FUNCTION__, name);
+
+        return;
+      }
+    }
+  }
+
+  CLog::Log(LOGDEBUG, "CDVDVideoCodecDRMPRIME::{} - no deinterlacing filter found",
+            __FUNCTION__);
+}
+
+bool CDVDVideoCodecDRMPRIME::FilterOpen(const std::string& filters, bool test)
 {
+  int result;
+
+  if (m_pFilterGraph)
+    FilterClose();
+
+  if (filters.empty())
+    return true;
+
+  if (!(m_pFilterGraph = avfilter_graph_alloc()))
+  {
+    CLog::Log(LOGERROR, "CDVDVideoCodecDRMPRIME::FilterOpen - unable to alloc filter graph");
+    return false;
+  }
+
+  AVBufferSrcParameters *par = av_buffersrc_parameters_alloc();
+  if (!par)
+  {
+    CLog::Log(LOGERROR, "CDVDVideoCodecDRMPRIME::FilterOpen - unable to alloc buffersrc params");
+    FilterClose();
+    return false;
+  }
+
+  const AVFilter* srcFilter = avfilter_get_by_name("buffer");
+  m_pFilterIn = avfilter_graph_alloc_filter(m_pFilterGraph, srcFilter, "in");
   if (!m_pFilterIn)
-    return VC_PICTURE;
+  {
+    CLog::Log(LOGERROR, "CDVDVideoCodecDRMPRIME::FilterOpen - unable to alloc in buffer");
+    FilterClose();
+    return false;
+  }
+
+  par->format = AV_PIX_FMT_DRM_PRIME;
+  par->hw_frames_ctx = m_pFrame->hw_frames_ctx;
+  par->time_base = m_pCodecContext->time_base;
+  par->width = m_pCodecContext->width;
+  par->height = m_pCodecContext->height;
+  par->sample_aspect_ratio = m_pCodecContext->sample_aspect_ratio;
+#if LIBAVFILTER_BUILD >= AV_VERSION_INT(10, 1, 100)
+  par->color_range = m_pCodecContext->color_range;
+  par->color_space = m_pCodecContext->colorspace;
+#endif
+
+  result = av_buffersrc_parameters_set(m_pFilterIn, par);
+  if (result < 0)
+  {
+    char err[AV_ERROR_MAX_STRING_SIZE] = {};
+    av_strerror(result, err, AV_ERROR_MAX_STRING_SIZE);
+    CLog::Log(LOGERROR,
+              "CDVDVideoCodecDRMPRIME::FilterOpen - av_buffersrc_parameters_set:  {} ({})",
+              err, result);
+    FilterClose();
+    return false;
+  }
+  av_freep(&par);
+
+  result = avfilter_init_dict(m_pFilterIn, NULL);
+  if (result < 0)
+  {
+    char err[AV_ERROR_MAX_STRING_SIZE] = {};
+    av_strerror(result, err, AV_ERROR_MAX_STRING_SIZE);
+    CLog::Log(LOGERROR,
+              "CDVDVideoCodecDRMPRIME::FilterOpen - avfilter_init_dict: src: {} ({})",
+              err, result);
+    FilterClose();
+    return false;
+  }
+
+  const AVFilter* outFilter = avfilter_get_by_name("buffersink");
+  m_pFilterOut = avfilter_graph_alloc_filter(m_pFilterGraph, outFilter, "out");
+  if (!m_pFilterOut)
+  {
+    CLog::Log(LOGERROR, "CDVDVideoCodecDRMPRIME::FilterOpen - unable to alloc out buffer");
+    FilterClose();
+    return false;
+  }
+
+  enum AVPixelFormat pix_fmts[] = { AV_PIX_FMT_DRM_PRIME, AV_PIX_FMT_NONE };
+#if LIBAVFILTER_BUILD >= AV_VERSION_INT(10, 6, 100)
+  result = av_opt_set_array(m_pFilterOut, "pixel_formats",
+                            AV_OPT_SEARCH_CHILDREN | AV_OPT_ARRAY_REPLACE,
+                            0, sizeof(pix_fmts)/sizeof(pix_fmts[0]) - 1,
+                            AV_OPT_TYPE_PIXEL_FMT, pix_fmts);
+#else
+  result = av_opt_set_int_list(m_pFilterOut, "pix_fmts", &pix_fmts[0],
+                               AV_PIX_FMT_NONE, AV_OPT_SEARCH_CHILDREN);
+#endif
+  if (result < 0)
+  {
+    CLog::Log(LOGERROR, "CDVDVideoCodecDRMPRIME::FilterOpen - failed settings pix formats ({})",
+              result);
+    FilterClose();
+    return false;
+  }
+
+  result = avfilter_init_dict(m_pFilterOut, NULL);
+  if (result < 0)
+  {
+    char err[AV_ERROR_MAX_STRING_SIZE] = {};
+    av_strerror(result, err, AV_ERROR_MAX_STRING_SIZE);
+    CLog::Log(LOGERROR,
+              "CDVDVideoCodecDRMPRIME::FilterOpen - avfilter_init_dict: out: {} ({})",
+              err, result);
+    FilterClose();
+    return false;
+  }
+
+  AVFilterInOut* outputs = avfilter_inout_alloc();
+  AVFilterInOut* inputs  = avfilter_inout_alloc();
+
+  outputs->name = av_strdup("in");
+  outputs->filter_ctx = m_pFilterIn;
+  outputs->pad_idx = 0;
+  outputs->next = nullptr;
+
+  inputs->name = av_strdup("out");
+  inputs->filter_ctx = m_pFilterOut;
+  inputs->pad_idx = 0;
+  inputs->next = nullptr;
+
+  result = avfilter_graph_parse_ptr(m_pFilterGraph, filters.c_str(), &inputs, &outputs, NULL);
+  avfilter_inout_free(&outputs);
+  avfilter_inout_free(&inputs);
+
+  if (result < 0)
+  {
+    CLog::Log(LOGERROR, "CDVDVideoCodecDRMPRIME::FilterOpen - avfilter_graph_parse");
+    FilterClose();
+    return false;
+  }
+
+  if ((result = avfilter_graph_config(m_pFilterGraph,  nullptr)) < 0)
+  {
+    char err[AV_ERROR_MAX_STRING_SIZE] = {};
+    av_strerror(result, err, AV_ERROR_MAX_STRING_SIZE);
+    CLog::Log(LOGERROR, "CDVDVideoCodecDRMPRIME::FilterOpen - avfilter_graph_config:  {} ({})",
+              err, result);
+    FilterClose();
+    return false;
+  }
+
+  if (test)
+  {
+    FilterClose();
+    return true;
+  }
+
+  m_processInfo.SetVideoDeintMethod(filters);
+
+  if (CServiceBroker::GetLogging().CanLogComponent(LOGVIDEO))
+  {
+    char* graphDump = avfilter_graph_dump(m_pFilterGraph, nullptr);
+    if (graphDump)
+    {
+      CLog::Log(LOGDEBUG, "CDVDVideoCodecDRMPRIME::FilterOpen - Final filter graph:\n{}",
+                graphDump);
+      av_freep(&graphDump);
+    }
+  }
+
+  return true;
+}
 
+void CDVDVideoCodecDRMPRIME::FilterClose()
+{
+  m_processInfo.SetVideoDeintMethod("none");
+  if (m_pFilterGraph)
+  {
+    CLog::Log(LOGDEBUG, LOGVIDEO, "CDVDVideoCodecDRMPRIME::FilterClose - Freeing filter graph");
+    avfilter_graph_free(&m_pFilterGraph);
+
+    // Disposed by above code
+    m_pFilterIn = nullptr;
+    m_pFilterOut = nullptr;
+  }
+}
+
+CDVDVideoCodec::VCReturn CDVDVideoCodecDRMPRIME::ProcessFilterIn()
+{
   int ret = av_buffersrc_add_frame(m_pFilterIn, m_pFrame);
   if (ret < 0)
   {
@@ -620,21 +868,14 @@ CDVDVideoCodec::VCReturn CDVDVideoCodecDRMPRIME::ProcessFilterIn()
 
 CDVDVideoCodec::VCReturn CDVDVideoCodecDRMPRIME::ProcessFilterOut()
 {
-  if (!m_pFilterOut)
-    return VC_EOF;
-
-  int ret = av_buffersink_get_frame(m_pFilterOut, m_pFrame);
+  int ret = av_buffersink_get_frame(m_pFilterOut, m_pFilterFrame);
   if (ret == AVERROR(EAGAIN))
     return VC_BUFFER;
   else if (ret == AVERROR_EOF)
   {
-    if (m_codecControlFlags & DVD_CODEC_CTRL_DRAIN)
-    {
-      CLog::Log(LOGDEBUG, "CDVDVideoCodecDRMPRIME::{} - flush buffers", __FUNCTION__);
-      avcodec_flush_buffers(m_pCodecContext);
-      SetCodecControl(m_codecControlFlags & ~DVD_CODEC_CTRL_DRAIN);
-    }
-    return VC_EOF;
+    ret = av_buffersink_get_frame(m_pFilterOut, m_pFilterFrame);
+    if (ret < 0)
+      return VC_BUFFER;
   }
   else if (ret)
   {
@@ -645,72 +886,124 @@ CDVDVideoCodec::VCReturn CDVDVideoCodecDRMPRIME::ProcessFilterOut()
     return VC_ERROR;
   }
 
+  av_frame_unref(m_pFrame);
+  av_frame_move_ref(m_pFrame, m_pFilterFrame);
+
   return VC_PICTURE;
 }
 
+std::string CDVDVideoCodecDRMPRIME::GetFilterChain(bool interlaced)
+{
+  // ask codec to do deinterlacing if possible
+  EINTERLACEMETHOD mInt = m_processInfo.GetVideoSettings().m_InterlaceMethod;
+  std::string filterChain;
+
+  if (!m_processInfo.Supports(mInt))
+    mInt = m_processInfo.GetFallbackDeintMethod();
+
+  // avoid disabling deinterlace graph for occasional progressive frames - they will be copied by deinterlace
+  if (!m_filters.empty())
+    interlaced = true;
+
+  if (mInt != VS_INTERLACEMETHOD_NONE && interlaced && !m_deintFilterName.empty())
+    filterChain += m_deintFilterName;
+
+  return filterChain;
+}
+
 CDVDVideoCodec::VCReturn CDVDVideoCodecDRMPRIME::GetPicture(VideoPicture* pVideoPicture)
 {
   if (m_codecControlFlags & DVD_CODEC_CTRL_DRAIN)
     Drain();
 
-  auto result = ProcessFilterOut();
-  if (result != VC_PICTURE)
+  if (m_pFilterGraph)
   {
-    int ret = avcodec_receive_frame(m_pCodecContext, m_pFrame);
-    if (ret == AVERROR(EAGAIN))
-      return VC_BUFFER;
-    else if (ret == AVERROR_EOF)
-      return VC_EOF;
-    else if (ret)
+    auto ret = ProcessFilterOut();
+    if (ret == VC_PICTURE)
     {
-      char err[AV_ERROR_MAX_STRING_SIZE] = {};
-      av_strerror(ret, err, AV_ERROR_MAX_STRING_SIZE);
-      CLog::Log(LOGERROR, "CDVDVideoCodecDRMPRIME::{} - receive frame failed: {} ({})",
-                __FUNCTION__, err, ret);
-      return VC_ERROR;
+      if (!SetPictureParams(pVideoPicture))
+        return VC_ERROR;
+      return VC_PICTURE;
+    }
+    else if (ret != VC_BUFFER)
+    {
+      return ret;
     }
-
-    result = ProcessFilterIn();
-    if (result != VC_PICTURE)
-      return result;
   }
 
-  SetPictureParams(pVideoPicture);
-
-  if (pVideoPicture->videoBuffer)
+  int ret = avcodec_receive_frame(m_pCodecContext, m_pFrame);
+  if (ret == AVERROR(EAGAIN))
+    return VC_BUFFER;
+  else if (ret == AVERROR_EOF)
   {
-    pVideoPicture->videoBuffer->Release();
-    pVideoPicture->videoBuffer = nullptr;
+    if (m_codecControlFlags & DVD_CODEC_CTRL_DRAIN)
+    {
+      CLog::Log(LOGDEBUG, "CDVDVideoCodecDRMPRIME::{} - flush buffers", __FUNCTION__);
+      avcodec_flush_buffers(m_pCodecContext);
+      SetCodecControl(m_codecControlFlags & ~DVD_CODEC_CTRL_DRAIN);
+    }
+    return VC_EOF;
   }
-
-  if (IsSupportedHwFormat(static_cast<AVPixelFormat>(m_pFrame->format)))
+  else if (ret)
   {
-    CVideoBufferDRMPRIMEFFmpeg* buffer =
-        dynamic_cast<CVideoBufferDRMPRIMEFFmpeg*>(m_videoBufferPool->Get());
-    buffer->SetPictureParams(*pVideoPicture);
-    buffer->SetRef(m_pFrame);
-    pVideoPicture->videoBuffer = buffer;
+    char err[AV_ERROR_MAX_STRING_SIZE] = {};
+    av_strerror(ret, err, AV_ERROR_MAX_STRING_SIZE);
+    CLog::Log(LOGERROR, "CDVDVideoCodecDRMPRIME::{} - receive frame failed: {} ({})",
+              __FUNCTION__, err, ret);
+    return VC_ERROR;
   }
-  else if (m_pFrame->opaque)
+
+  if (!m_checkedDeinterlace)
   {
-    CVideoBufferDMA* buffer = static_cast<CVideoBufferDMA*>(m_pFrame->opaque);
-    buffer->SetPictureParams(*pVideoPicture);
-    buffer->Acquire();
-    buffer->SyncEnd();
-    buffer->SetDimensions(m_pFrame->width, m_pFrame->height);
+    FilterTest();
 
-    pVideoPicture->videoBuffer = buffer;
-    av_frame_unref(m_pFrame);
+    if (!m_deintFilterName.empty())
+    {
+      std::list<EINTERLACEMETHOD> methods;
+      methods.push_back(EINTERLACEMETHOD::VS_INTERLACEMETHOD_DEINTERLACE);
+      m_processInfo.UpdateDeinterlacingMethods(methods);
+      m_processInfo.SetDeinterlacingMethodDefault(EINTERLACEMETHOD::VS_INTERLACEMETHOD_DEINTERLACE);
+    }
+    m_checkedDeinterlace = true;
   }
 
-  if (!pVideoPicture->videoBuffer)
+  if (!m_processInfo.GetVideoInterlaced() && (m_pFrame->flags & AV_FRAME_FLAG_INTERLACED) != 0)
+    m_processInfo.SetVideoInterlaced(true);
+
+  std::string filterChain = GetFilterChain((m_pFrame->flags & AV_FRAME_FLAG_INTERLACED) != 0);
+  if (!filterChain.empty())
   {
-    CLog::Log(LOGERROR, "CDVDVideoCodecDRMPRIME::{} - videoBuffer:nullptr format:{}", __FUNCTION__,
-              av_get_pix_fmt_name(static_cast<AVPixelFormat>(m_pFrame->format)));
-    av_frame_unref(m_pFrame);
-    return VC_ERROR;
+    bool reopenFilter = false;
+    if (m_filters != filterChain)
+      reopenFilter = true;
+
+    if (m_pFilterGraph &&
+        (m_pFilterIn->outputs[0]->w != m_pCodecContext->width ||
+         m_pFilterIn->outputs[0]->h != m_pCodecContext->height))
+      reopenFilter = true;
+
+    if (reopenFilter)
+    {
+      m_filters = filterChain;
+      if (!FilterOpen(filterChain, false))
+        FilterClose();
+    }
+
+    if (m_pFilterGraph)
+    {
+      if (ProcessFilterIn() != VC_PICTURE)
+        return VC_NONE;
+    }
+  }
+  else
+  {
+    m_filters.clear();
+    FilterClose();
   }
 
+  if (!SetPictureParams(pVideoPicture))
+    return VC_ERROR;
+
   return VC_PICTURE;
 }
 
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecDRMPRIME.h b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecDRMPRIME.h
index b5cacf1a3c99..c9c163a6e1c5 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecDRMPRIME.h
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecDRMPRIME.h
@@ -38,19 +38,27 @@ public:
 
 protected:
   void Drain();
-  void SetPictureParams(VideoPicture* pVideoPicture);
+  bool SetPictureParams(VideoPicture* pVideoPicture);
   void UpdateProcessInfo(struct AVCodecContext* avctx, const enum AVPixelFormat fmt);
   CDVDVideoCodec::VCReturn ProcessFilterIn();
   CDVDVideoCodec::VCReturn ProcessFilterOut();
   static enum AVPixelFormat GetFormat(struct AVCodecContext* avctx, const enum AVPixelFormat* fmt);
   static int GetBuffer(struct AVCodecContext* avctx, AVFrame* frame, int flags);
+  bool FilterOpen(const std::string& filters, bool test);
+  void FilterClose();
+  void FilterTest();
+  std::string GetFilterChain(bool interlaced);
 
   std::string m_name;
+  std::string m_deintFilterName;
+  std::string m_filters;
   int m_codecControlFlags = 0;
   CDVDStreamInfo m_hints;
   double m_DAR = 1.0;
+  bool m_checkedDeinterlace = false;
   AVCodecContext* m_pCodecContext = nullptr;
   AVFrame* m_pFrame = nullptr;
+  AVFrame* m_pFilterFrame = nullptr;
   AVFilterGraph* m_pFilterGraph = nullptr;
   AVFilterContext* m_pFilterIn = nullptr;
   AVFilterContext* m_pFilterOut = nullptr;
-- 
2.47.3

