From aab0ad78f39e3c988256fab71a4498d93e098bad Mon Sep 17 00:00:00 2001
From: Pauli Virtanen <pav@iki.fi>
Date: Tue, 5 Aug 2025 23:27:36 +0300
Subject: [PATCH] [AudioEngine] PipeWire: synchronize to Process() callback

Pull data synchronously with the stream's Process() callback, instead of
pushing buffers asynchronously. This simplifies the pw_stream API usage.

Queue one buffer for each Process() cycle, with exactly the requested
number of samples. Then we don't need extra buffers, so don't request
them.

Adjust CPipewireStream to make this a bit easier. Have Process() block
until a buffer is queued. This uses the loop.Signal(true) <->
loop.Accept() condition variable in pw_thread_loop.

Bump requested PW_KEY_NODE_LATENCY up: this is the request for the
maximum total software buffer delay, so for media playback it doesn't
need to be small.

Fixes audio stutter for sinks that report long output latency (eg.
Bluetooth). This change also reduces the actual audio output latency,
since we only queue the amount of audio needed.
---
 .../Sinks/pipewire/AESinkPipewire.cpp         | 119 +++++++++---------
 .../Sinks/pipewire/PipewireStream.cpp         |  82 +++++++++---
 .../Sinks/pipewire/PipewireStream.h           |  16 ++-
 .../Sinks/pipewire/PipewireThreadLoop.cpp     |   5 +
 .../Sinks/pipewire/PipewireThreadLoop.h       |   1 +
 5 files changed, 138 insertions(+), 85 deletions(-)

diff --git a/xbmc/cores/AudioEngine/Sinks/pipewire/AESinkPipewire.cpp b/xbmc/cores/AudioEngine/Sinks/pipewire/AESinkPipewire.cpp
index 81360ce41aee2..943024403d6dc 100644
--- a/xbmc/cores/AudioEngine/Sinks/pipewire/AESinkPipewire.cpp
+++ b/xbmc/cores/AudioEngine/Sinks/pipewire/AESinkPipewire.cpp
@@ -20,6 +20,8 @@
 #include "utils/StringUtils.h"
 #include "utils/log.h"
 
+#include <algorithm>
+
 #include <pipewire/keys.h>
 #include <spa/param/audio/format-utils.h>
 #include <spa/param/audio/raw.h>
@@ -237,12 +239,8 @@ std::chrono::duration<double, std::ratio<1>> PWTimeToAEDelay(const pw_time& time
   return delay;
 }
 
-constexpr std::chrono::duration<double, std::ratio<1>> DEFAULT_BUFFER_DURATION = 0.200s;
-constexpr int DEFAULT_PERIODS = 4;
-constexpr std::chrono::duration<double, std::ratio<1>> DEFAULT_PERIOD_DURATION =
-    DEFAULT_BUFFER_DURATION / DEFAULT_PERIODS;
-
-constexpr int DEFAULT_LATENCY_DIVIDER = 3;
+constexpr std::chrono::duration<double, std::ratio<1>> DEFAULT_BUFFER_DURATION = 0.100s;
+constexpr unsigned int DEFAULT_NUM_PERIODS = 2;
 
 } // namespace
 
@@ -421,10 +419,11 @@ bool CAESinkPipewire::Initialize(AEAudioFormat& format, std::string& device)
 
   m_stream = std::make_unique<PIPEWIRE::CPipewireStream>(core);
 
-  m_latency = DEFAULT_BUFFER_DURATION;
-  uint32_t frames = std::nearbyint(DEFAULT_PERIOD_DURATION.count() * format.m_sampleRate);
-  std::string fraction =
-      StringUtils::Format("{}/{}", frames / DEFAULT_LATENCY_DIVIDER, format.m_sampleRate);
+  uint32_t frames =
+      std::nearbyint((DEFAULT_BUFFER_DURATION / DEFAULT_NUM_PERIODS).count() * format.m_sampleRate);
+  std::string fraction = StringUtils::Format("{}/{}", frames, format.m_sampleRate);
+
+  m_latency = DEFAULT_NUM_PERIODS * frames * 1.0s / format.m_sampleRate;
 
   std::string srate = StringUtils::Format("1/{}", format.m_sampleRate);
 
@@ -451,17 +450,16 @@ bool CAESinkPipewire::Initialize(AEAudioFormat& format, std::string& device)
   std::vector<const spa_pod*> params;
 
   // clang-format off
+  uint32_t buf_minsize = frames * pwChannels.size() * PWFormatToSampleSize(pwFormat);
   params.emplace_back(static_cast<const spa_pod*>(spa_pod_builder_add_object(
       &builder, SPA_TYPE_OBJECT_ParamBuffers, SPA_PARAM_Buffers,
-          SPA_PARAM_BUFFERS_buffers, SPA_POD_CHOICE_RANGE_Int(20, 16, 24),
           SPA_PARAM_BUFFERS_blocks, SPA_POD_Int(1),
-          SPA_PARAM_BUFFERS_size, SPA_POD_Int(frames * pwChannels.size() * PWFormatToSampleSize(pwFormat)),
+          SPA_PARAM_BUFFERS_size, SPA_POD_CHOICE_RANGE_Int(buf_minsize, buf_minsize, INT32_MAX),
           SPA_PARAM_BUFFERS_stride, SPA_POD_Int(pwChannels.size() * PWFormatToSampleSize(pwFormat)))));
   // clang-format on
 
-  pw_stream_flags flags =
-      static_cast<pw_stream_flags>(PW_STREAM_FLAG_AUTOCONNECT | PW_STREAM_FLAG_INACTIVE |
-                                   PW_STREAM_FLAG_MAP_BUFFERS | PW_STREAM_FLAG_DRIVER);
+  pw_stream_flags flags = static_cast<pw_stream_flags>(
+      PW_STREAM_FLAG_AUTOCONNECT | PW_STREAM_FLAG_INACTIVE | PW_STREAM_FLAG_MAP_BUFFERS);
 
   if (!passthrough)
   {
@@ -502,8 +500,7 @@ bool CAESinkPipewire::Initialize(AEAudioFormat& format, std::string& device)
   CLog::Log(LOGDEBUG, "CAESinkPipewire::{} - framesize: {}", __FUNCTION__,
             pwChannels.size() * PWFormatToSampleSize(pwFormat));
   CLog::Log(LOGDEBUG, "CAESinkPipewire::{} - latency: {}/{} ({:.3f}s)", __FUNCTION__, frames,
-            format.m_sampleRate,
-            static_cast<double>(frames) / DEFAULT_LATENCY_DIVIDER / format.m_sampleRate);
+            format.m_sampleRate, static_cast<double>(frames) / format.m_sampleRate);
 
   pw_stream_state state;
   do
@@ -549,9 +546,11 @@ double CAESinkPipewire::GetCacheTotal()
   return m_latency.count();
 }
 
-unsigned int CAESinkPipewire::AddPackets(uint8_t** data, unsigned int frames, unsigned int offset)
+unsigned int CAESinkPipewire::AddPackets(uint8_t** data,
+                                         unsigned int frames_in,
+                                         unsigned int offset)
 {
-  const auto start = std::chrono::steady_clock::now();
+  unsigned int frames = frames_in;
 
   auto& loop = pipewire->GetThreadLoop();
 
@@ -559,59 +558,57 @@ unsigned int CAESinkPipewire::AddPackets(uint8_t** data, unsigned int frames, un
 
   if (m_stream->GetState() == PW_STREAM_STATE_PAUSED)
     m_stream->SetActive(true);
+  else if (m_stream->GetState() != PW_STREAM_STATE_STREAMING)
+    return 0;
 
-  pw_buffer* pwBuffer = nullptr;
-  while (!pwBuffer)
+  while (frames)
   {
-    pwBuffer = m_stream->DequeueBuffer();
-    if (pwBuffer)
-      break;
+    // Block until data is needed. Process() will wake us up.
+    while (!m_stream->NeedsData())
+    {
+      int ret = loop.Wait(1s);
+      if (ret < 0)
+        return 0;
+    }
 
-    int ret = loop.Wait(1s);
-    if (ret == -ETIMEDOUT)
+    // Fill in exactly the requested number of frames. If we don't have enough,
+    // don't queue the buffer yet. Important for passthrough, and also for pcm
+    // since we didn't request extra buffers when creating stream.
+    pw_buffer* buffer = m_stream->GetBuffer();
+    if (!buffer)
       return 0;
-  }
-
-  pwBuffer->size = frames;
-
-  spa_buffer* spaBuffer = pwBuffer->buffer;
-  spa_data* spaData = &spaBuffer->datas[0];
-
-  size_t length = frames * m_format.m_frameSize;
-
-  void* buffer = data[0] + offset * m_format.m_frameSize;
-
-  std::memcpy(spaData->data, buffer, length);
 
-  spaData->chunk->offset = 0;
-  spaData->chunk->stride = m_format.m_frameSize;
-  spaData->chunk->size = length;
+    spa_buffer* spaBuffer = buffer->buffer;
+    spa_data* spaData = &spaBuffer->datas[0];
+    unsigned int max_frames = spaData->maxsize / m_format.m_frameSize;
+    unsigned int requested = buffer->requested ? buffer->requested : frames;
+    unsigned int target = std::min(requested, max_frames);
 
-  m_stream->QueueBuffer(pwBuffer);
-
-  const auto period = std::chrono::duration<double, std::ratio<1>>(static_cast<double>(frames) /
-                                                                   m_format.m_sampleRate);
-
-  do
-  {
-    pw_time time = m_stream->GetTime();
-
-    const std::chrono::duration<double, std::ratio<1>> delay =
-        PWTimeToAEDelay(time, m_format.m_sampleRate);
-
-    const auto now = std::chrono::steady_clock::now();
+    if (buffer->size < target)
+    {
+      unsigned int consume = std::min(frames, static_cast<unsigned int>(target - buffer->size));
+      size_t length = consume * m_format.m_frameSize;
+      void* dst = static_cast<uint8_t*>(spaData->data) + buffer->size * m_format.m_frameSize;
+      void* src = data[0] + offset * m_format.m_frameSize;
 
-    if ((delay <= (DEFAULT_BUFFER_DURATION - DEFAULT_PERIOD_DURATION)) || ((now - start) >= period))
-      break;
+      std::memcpy(dst, src, length);
 
-    loop.Wait(5ms);
+      buffer->size += consume;
+      frames -= consume;
+      offset += consume;
+    }
 
-  } while (true);
+    if (buffer->size >= target)
+    {
+      spaData->chunk->offset = 0;
+      spaData->chunk->stride = m_format.m_frameSize;
+      spaData->chunk->size = buffer->size * m_format.m_frameSize;
 
-  if (m_stream->IsDriving())
-    m_stream->TriggerProcess();
+      m_stream->QueueBuffer();
+    }
+  }
 
-  return frames;
+  return frames_in;
 }
 
 void CAESinkPipewire::GetDelay(AEDelayStatus& status)
diff --git a/xbmc/cores/AudioEngine/Sinks/pipewire/PipewireStream.cpp b/xbmc/cores/AudioEngine/Sinks/pipewire/PipewireStream.cpp
index dd7e952c0a185..31bdb65e7de50 100644
--- a/xbmc/cores/AudioEngine/Sinks/pipewire/PipewireStream.cpp
+++ b/xbmc/cores/AudioEngine/Sinks/pipewire/PipewireStream.cpp
@@ -21,7 +21,11 @@ using namespace KODI;
 using namespace PIPEWIRE;
 
 CPipewireStream::CPipewireStream(CPipewireCore& core)
-  : m_core(core), m_streamEvents(CreateStreamEvents())
+  : m_core(core),
+    m_streamEvents(CreateStreamEvents()),
+    m_buffer(nullptr),
+    m_waiting(false),
+    m_running(false)
 {
   m_stream.reset(pw_stream_new(core.Get(), nullptr, pw_properties_new(nullptr, nullptr)));
   if (!m_stream)
@@ -33,9 +37,27 @@ CPipewireStream::CPipewireStream(CPipewireCore& core)
   pw_stream_add_listener(m_stream.get(), &m_streamListener, &m_streamEvents, this);
 }
 
+void CPipewireStream::Stop()
+{
+  using namespace std::chrono_literals;
+  auto& loop = GetCore().GetContext().GetThreadLoop();
+
+  // Stop blocking in Process(), nothing produces samples any more
+  m_running = false;
+
+  // If Process() is blocking, wake it up
+  if (m_waiting)
+  {
+    loop.Accept();
+    while (m_waiting)
+      loop.Wait(1s);
+  }
+}
+
 CPipewireStream::~CPipewireStream()
 {
   spa_hook_remove(&m_streamListener);
+  Stop();
 }
 
 bool CPipewireStream::Connect(uint32_t id,
@@ -60,38 +82,48 @@ pw_stream_state CPipewireStream::GetState()
 
 void CPipewireStream::SetActive(bool active)
 {
+  if (!active)
+    Stop();
   pw_stream_set_active(m_stream.get(), active);
+  m_running = active;
 }
 
-pw_buffer* CPipewireStream::DequeueBuffer()
+pw_buffer* CPipewireStream::GetBuffer()
 {
-  return pw_stream_dequeue_buffer(m_stream.get());
+  if (!m_buffer)
+  {
+    m_buffer = pw_stream_dequeue_buffer(m_stream.get());
+    if (m_buffer)
+      m_buffer->size = 0;
+  }
+  return m_buffer;
 }
 
-void CPipewireStream::QueueBuffer(pw_buffer* buffer)
+void CPipewireStream::QueueBuffer()
 {
-  pw_stream_queue_buffer(m_stream.get(), buffer);
-}
+  auto& loop = GetCore().GetContext().GetThreadLoop();
 
-bool CPipewireStream::IsDriving() const
-{
-  return pw_stream_is_driving(m_stream.get());
-}
+  if (!m_buffer)
+    return;
 
-bool CPipewireStream::TriggerProcess() const
-{
-  int ret = pw_stream_trigger_process(m_stream.get());
-  if (ret < 0)
+  pw_stream_queue_buffer(m_stream.get(), m_buffer);
+  m_buffer = nullptr;
+
+  if (m_waiting)
   {
-    CLog::Log(LOGERROR, "CPipewireStream: failed to trigger process: {}", spa_strerror(errno));
-    return false;
+    m_waiting = false;
+    loop.Accept();
   }
+}
 
-  return true;
+bool CPipewireStream::NeedsData() const
+{
+  return m_waiting;
 }
 
 void CPipewireStream::Flush(bool drain)
 {
+  Stop();
   pw_stream_flush(m_stream.get(), drain);
 }
 
@@ -139,7 +171,21 @@ void CPipewireStream::Process(void* userdata)
   auto& stream = *reinterpret_cast<CPipewireStream*>(userdata);
   auto& loop = stream.GetCore().GetContext().GetThreadLoop();
 
-  loop.Signal(false);
+  // Block thread loop until there is enough data.
+  // This is allowed since we are running without PW_STREAM_FLAG_RT_PROCESS.
+  stream.m_waiting = stream.m_running;
+  while (stream.m_waiting)
+  {
+    if (!stream.m_running)
+    {
+      stream.m_waiting = false;
+      loop.Signal(false);
+      return;
+    }
+
+    // Wake up AddPackets() and wait for notify from QueueBuffer()
+    loop.Signal(true);
+  }
 }
 
 void CPipewireStream::Drained(void* userdata)
diff --git a/xbmc/cores/AudioEngine/Sinks/pipewire/PipewireStream.h b/xbmc/cores/AudioEngine/Sinks/pipewire/PipewireStream.h
index 494fa948c30ba..d2183a72d7112 100644
--- a/xbmc/cores/AudioEngine/Sinks/pipewire/PipewireStream.h
+++ b/xbmc/cores/AudioEngine/Sinks/pipewire/PipewireStream.h
@@ -40,12 +40,8 @@ class CPipewireStream
   pw_stream_state GetState();
   void SetActive(bool active);
 
-  pw_buffer* DequeueBuffer();
-  void QueueBuffer(pw_buffer* buffer);
-
-  bool IsDriving() const;
-
-  bool TriggerProcess() const;
+  pw_buffer* GetBuffer();
+  void QueueBuffer();
 
   void Flush(bool drain);
 
@@ -55,6 +51,8 @@ class CPipewireStream
 
   pw_time GetTime() const;
 
+  bool NeedsData() const;
+
 private:
   static void StateChanged(void* userdata,
                            enum pw_stream_state old,
@@ -62,6 +60,7 @@ class CPipewireStream
                            const char* error);
   static void Process(void* userdata);
   static void Drained(void* userdata);
+  void Stop();
 
   static pw_stream_events CreateStreamEvents();
 
@@ -71,6 +70,11 @@ class CPipewireStream
 
   spa_hook m_streamListener;
 
+  pw_buffer* m_buffer;
+
+  bool m_waiting;
+  bool m_running;
+
   struct PipewireStreamDeleter
   {
     void operator()(pw_stream* p) { pw_stream_destroy(p); }
diff --git a/xbmc/cores/AudioEngine/Sinks/pipewire/PipewireThreadLoop.cpp b/xbmc/cores/AudioEngine/Sinks/pipewire/PipewireThreadLoop.cpp
index 8d3f8a6b92b0e..9fbfec3f63953 100644
--- a/xbmc/cores/AudioEngine/Sinks/pipewire/PipewireThreadLoop.cpp
+++ b/xbmc/cores/AudioEngine/Sinks/pipewire/PipewireThreadLoop.cpp
@@ -57,3 +57,8 @@ void CPipewireThreadLoop::Signal(bool accept)
 {
   pw_thread_loop_signal(m_mainloop.get(), accept);
 }
+
+void CPipewireThreadLoop::Accept()
+{
+  pw_thread_loop_accept(m_mainloop.get());
+}
diff --git a/xbmc/cores/AudioEngine/Sinks/pipewire/PipewireThreadLoop.h b/xbmc/cores/AudioEngine/Sinks/pipewire/PipewireThreadLoop.h
index 22113304d873b..d0bebcbdfb283 100644
--- a/xbmc/cores/AudioEngine/Sinks/pipewire/PipewireThreadLoop.h
+++ b/xbmc/cores/AudioEngine/Sinks/pipewire/PipewireThreadLoop.h
@@ -34,6 +34,7 @@ class CPipewireThreadLoop
 
   int Wait(std::chrono::nanoseconds timeout);
   void Signal(bool accept);
+  void Accept();
 
 private:
   struct PipewireThreadLoopDeleter
