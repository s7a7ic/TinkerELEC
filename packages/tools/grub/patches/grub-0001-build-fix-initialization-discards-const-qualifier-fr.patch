From 9386516acb680406f6a299895e90316241b1b8f4 Mon Sep 17 00:00:00 2001
From: Rudi Heitbaum <rudi@heitbaum.com>
Date: Mon, 26 Jan 2026 22:35:29 +0000
Subject: [PATCH] build: fix initialization discards 'const' qualifier from
 pointer target type

Since glibc-2.43:

For ISO C23, the functions bsearch, memchr, strchr, strpbrk, strrchr,
strstr, wcschr, wcspbrk, wcsrchr, wcsstr and wmemchr that return
pointers into their input arrays now have definitions as macros that
return a pointer to a const-qualified type when the input argument is
a pointer to a const-qualified type.

https://lists.gnu.org/archive/html/info-gnu/2026-01/msg00005.html

Signed-off-by: Rudi Heitbaum <rudi@heitbaum.com>
---
 grub-core/osdep/linux/ofpath.c |  15 +++--
 util/probe.c                   | 117 +++++++++++++++++++++++----------
 util/resolve.c                 |  10 +--
 3 files changed, 94 insertions(+), 48 deletions(-)

diff --git a/grub-core/osdep/linux/ofpath.c b/grub-core/osdep/linux/ofpath.c
index 24a4d5c8d..c2d1e8c14 100644
--- a/grub-core/osdep/linux/ofpath.c
+++ b/grub-core/osdep/linux/ofpath.c
@@ -488,7 +488,8 @@ check_hba_identifiers (const char *sysfs_path, int *vendor, int *device_id)
 static void
 check_sas (const char *sysfs_path, int *tgt, unsigned long int *sas_address)
 {
-  char *ed = strstr (sysfs_path, "end_device");
+  const char *ed = strstr (sysfs_path, "end_device");
+  char *ed2;
   char *p, *q, *path;
   char phy[21];
   int fd;
@@ -499,19 +500,19 @@ check_sas (const char *sysfs_path, int *tgt, unsigned long int *sas_address)
 
   /* SAS devices are identified using disk@$PHY_ID */
   p = xstrdup (sysfs_path);
-  ed = strstr(p, "end_device");
-  if (!ed)
+  ed2 = strstr(p, "end_device");
+  if (!ed2)
     return;
 
-  q = ed;
+  q = ed2;
   while (*q && *q != '/')
     q++;
   *q = '\0';
 
-  path_size = (strlen (p) + strlen (ed)
+  path_size = (strlen (p) + strlen (ed2)
 	       + sizeof ("%s/sas_device/%s/phy_identifier"));
   path = xmalloc (path_size);
-  snprintf (path, path_size, "%s/sas_device/%s/phy_identifier", p, ed);
+  snprintf (path, path_size, "%s/sas_device/%s/phy_identifier", p, ed2);
   fd = open (path, O_RDONLY);
   if (fd < 0)
     grub_util_error (_("cannot open `%s': %s"), path, strerror (errno));
@@ -524,7 +525,7 @@ check_sas (const char *sysfs_path, int *tgt, unsigned long int *sas_address)
 
   sscanf (phy, "%d", tgt);
 
-  snprintf (path, path_size, "%s/sas_device/%s/sas_address", p, ed);
+  snprintf (path, path_size, "%s/sas_device/%s/sas_address", p, ed2);
   fd = open (path, O_RDONLY);
   if (fd < 0)
     grub_util_error (_("cannot open `%s': %s"), path, strerror (errno));
diff --git a/util/probe.c b/util/probe.c
index 81d91cf59..5d1858cf2 100644
--- a/util/probe.c
+++ b/util/probe.c
@@ -70,26 +70,41 @@ char *
 grub_util_guess_bios_drive (const char *orig_path)
 {
   char *canon;
-  char *ptr;
+  const char *ptr;
   canon = grub_canonicalize_file_name (orig_path);
   if (!canon)
     return NULL;
   ptr = strrchr (orig_path, '/');
   if (ptr)
-    ptr++;
-  else
-    ptr = canon;
-  if ((ptr[0] == 's' || ptr[0] == 'h') && ptr[1] == 'd')
     {
-      int num = ptr[2] - 'a';
-      free (canon);
-      return xasprintf ("hd%d", num);
+      ptr++;
+      if ((ptr[0] == 's' || ptr[0] == 'h') && ptr[1] == 'd')
+        {
+          int num = ptr[2] - 'a';
+          free (canon);
+          return xasprintf ("hd%d", num);
+        }
+      if (ptr[0] == 'f' && ptr[1] == 'd')
+        {
+          int num = atoi (ptr + 2);
+          free (canon);
+          return xasprintf ("fd%d", num);
+        }
     }
-  if (ptr[0] == 'f' && ptr[1] == 'd')
+  else
     {
-      int num = atoi (ptr + 2);
-      free (canon);
-      return xasprintf ("fd%d", num);
+      if ((canon[0] == 's' || canon[0] == 'h') && canon[1] == 'd')
+        {
+          int num = canon[2] - 'a';
+          free (canon);
+          return xasprintf ("hd%d", num);
+        }
+      if (canon[0] == 'f' && canon[1] == 'd')
+        {
+          int num = atoi (canon + 2);
+          free (canon);
+          return xasprintf ("fd%d", num);
+        }
     }
   free (canon);
   return NULL;
@@ -99,26 +114,41 @@ char *
 grub_util_guess_efi_drive (const char *orig_path)
 {
   char *canon;
-  char *ptr;
+  const char *ptr;
   canon = grub_canonicalize_file_name (orig_path);
   if (!canon)
     return NULL;
   ptr = strrchr (orig_path, '/');
   if (ptr)
-    ptr++;
-  else
-    ptr = canon;
-  if ((ptr[0] == 's' || ptr[0] == 'h') && ptr[1] == 'd')
     {
-      int num = ptr[2] - 'a';
-      free (canon);
-      return xasprintf ("hd%d", num);
+      ptr++;
+      if ((ptr[0] == 's' || ptr[0] == 'h') && ptr[1] == 'd')
+        {
+          int num = ptr[2] - 'a';
+          free (canon);
+          return xasprintf ("hd%d", num);
+        }
+      if (ptr[0] == 'f' && ptr[1] == 'd')
+        {
+          int num = atoi (ptr + 2);
+          free (canon);
+          return xasprintf ("fd%d", num);
+        }
     }
-  if (ptr[0] == 'f' && ptr[1] == 'd')
+  else
     {
-      int num = atoi (ptr + 2);
-      free (canon);
-      return xasprintf ("fd%d", num);
+      if ((canon[0] == 's' || canon[0] == 'h') && canon[1] == 'd')
+        {
+          int num = canon[2] - 'a';
+          free (canon);
+          return xasprintf ("hd%d", num);
+        }
+      if (canon[0] == 'f' && canon[1] == 'd')
+        {
+          int num = atoi (canon + 2);
+          free (canon);
+          return xasprintf ("fd%d", num);
+        }
     }
   free (canon);
   return NULL;
@@ -128,26 +158,41 @@ char *
 grub_util_guess_baremetal_drive (const char *orig_path)
 {
   char *canon;
-  char *ptr;
+  const char *ptr;
   canon = grub_canonicalize_file_name (orig_path);
   if (!canon)
     return NULL;
   ptr = strrchr (orig_path, '/');
   if (ptr)
-    ptr++;
-  else
-    ptr = canon;
-  if (ptr[0] == 'h' && ptr[1] == 'd')
     {
-      int num = ptr[2] - 'a';
-      free (canon);
-      return xasprintf ("ata%d", num);
+      ptr++;
+      if (ptr[0] == 'h' && ptr[1] == 'd')
+        {
+          int num = ptr[2] - 'a';
+          free (canon);
+          return xasprintf ("ata%d", num);
+        }
+      if (ptr[0] == 's' && ptr[1] == 'd')
+        {
+          int num = ptr[2] - 'a';
+          free (canon);
+          return xasprintf ("ahci%d", num);
+        }
     }
-  if (ptr[0] == 's' && ptr[1] == 'd')
+  else
     {
-      int num = ptr[2] - 'a';
-      free (canon);
-      return xasprintf ("ahci%d", num);
+      if (canon[0] == 'h' && canon[1] == 'd')
+        {
+          int num = canon[2] - 'a';
+          free (canon);
+          return xasprintf ("ata%d", num);
+        }
+      if (canon[0] == 's' && canon[1] == 'd')
+        {
+          int num = canon[2] - 'a';
+          free (canon);
+          return xasprintf ("ahci%d", num);
+        }
     }
   free (canon);
   return NULL;
diff --git a/util/resolve.c b/util/resolve.c
index b6e26312f..254379195 100644
--- a/util/resolve.c
+++ b/util/resolve.c
@@ -138,12 +138,12 @@ read_dep_list (FILE *fp)
 static char *
 get_module_name (const char *str)
 {
-  char *base;
-  char *ext;
+  const char *base;
+  const char *ext;
 
   base = strrchr (str, '/');
   if (! base)
-    base = (char *) str;
+    base = str;
   else
     base++;
 
@@ -164,9 +164,9 @@ get_module_name (const char *str)
 static char *
 get_module_path (const char *prefix, const char *str)
 {
-  char *dir;
+  const char *dir;
   char *base;
-  char *ext;
+  const char *ext;
   char *ret;
 
   ext = strrchr (str, '.');
-- 
2.51.0

